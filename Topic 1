The following code demonstrates different ways to handle missing data replacement in R, progressing from manual coding to efficient functional programming with functions and closures, and finally applying multiple functions to data succinctly.

Motivation and Data Creation
x = matrix(sample(c(1:10, -999), 36, rep = TRUE), nrow=6 )
df <- data.frame(x)
names(df) <- letters[1:6]
df

Replacing -999 with NA (Missing Values)
df$a[df$a == -999] <- NA
df$b[df$b == -999] <- NA
df$c[df$c == -989] <- NA
df$d[df$d == -999] <- NA
df$e[df$e == -999] <- NA
df$f[df$g == -999] <- NA

Defining and Using a Function to Replace -999 with NA
fix_missing <- function(x) {
  x[x == -999] <- NA
  x
}

df$a <- fix_missing(df$a)
df$b <- fix_missing(df$b)
df$c <- fix_missing(df$c)
df$d <- fix_missing(df$d)
df$e <- fix_missing(df$e)
df$f <- fix_missing(df$e)

Efficient Way: Replace -999 in All Columns Using lapply
fix_missing <- function(x) {
  x[x == -99] <- NA
  x
}

df[] <- lapply(df, fix_missing)


Building Blocks of Functional Programming (FP) in R
1. Anonymous Functions
formals(function(x = 4) g(x) + h(x))
body(function(x = 4) g(x) + h(x))
environment(function(x = 4) g(x) + h(x))

2. Closure: Functions Returning Functions
power <- function(exponent) {
  function(x) {
    x ^ exponent
  }
}

square <- power(2)
cube <- power(3)

3. List of Functions and Applying Them
funs2 <- list(
  sum = function(x, ...) sum(x, ..., na.rm = TRUE),
  mean = function(x, ...) mean(x, ..., na.rm = TRUE),
  median = function(x, ...) median(x, ..., na.rm = TRUE)
)

lapply(funs2, function(f) f(x))

